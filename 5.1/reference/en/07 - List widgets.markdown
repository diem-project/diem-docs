A list widget displays a set of records on the front application. It is composed with a component and partial, and can be configured through the widget edition dialog.

Let's assume we have a "post" module.
We want to show the posts list.
*config/dm/modules.yml*
[code]
Content:
  Blog:
    post:
      components:
        list:
[/code]

The front component has been generated and contains:
*apps/front/modules/post/actions/components.class.php*
[code php]
class postComponents extends myFrontModuleComponents
{
  public function executeList()
  {
    // generate the query
    $query = $this->getListQuery();
    // generate the pager for this query
    $this->postPager = $this->getPager($query);
  }
[/code]

## List filters
Imagine you want a list of posts, only for a given category of posts. You have a Post model and a Category model, with a one-to-many or even a many-to-many relation.
You can declare a list of articles filtered by a category:
*config/dm/modules.yml*
[code]
Content:
  Blog:

    category:

    post:
      components:
        listByCategory: { filters: category }
[/code]
When adding this widget to the page, the edition dialog shows a select where you can choose the category to filter by. If Diem can guess the current category from the page context, it will propose a [contextual] entry in the select. By choosing [contextual], the category used will change depending on the page.

### Access the category filtered with


## Customize the list query

The list query is generated and ready to use without any interventions.
By default, the list query:

- joins the i18n table if any
- filters on is_active field if any
- orders by selected field on widget dialog
- filters on selected module on widget dialog

Anyway, you can customize it to handle specific constraints or minimize SQL queries.

### Choose the root alias
If you plan on customizing the query, you should first choose a root alias by passing it as the first argument of getListQuery():
[code php]
$query = $this->getListQuery('post'); // you can choose any string you want
[/code]

### Add conditions
You can add where clauses as for any doctrine query.
[code php]
$query = $this->getListQuery('post')
->addWhere('post.name LIKE ?', '%symfony%');
[/code]

### Join I18n table
If the model is translatable, the i18n join is done automatically and does not require your intervention. The i18n alias is generated by adding 'Translation' to your root alias.

### Add conditions on i18n table
In this example, the i18n alias is 'postTranslation', so we can add a clause on translated fields.
[code php]
$query = $this->getListQuery('post')
->addWhere('postTranslation.description LIKE ?', '%symfony%');
[/code]

### Add joins to reduce SQL queries
If the Post model has an Author relation, we can join it now to prevent the Author to be loaded for each Post.
[code php]
$query = $this->getListQuery('post')
->leftJoin('post.Author author');
[/code]
If the Post model has a relation to DmMedia named 'Image', you can use the following shortcut:
[code php]
$query = $this->getListQuery('post')
->withMedia('Image');
[/code]

## Customize the list pager

The list pager is responsible for selecting and displaying a subset of the matched records, and render pagination links.
It's highly configurable. You can pass options:

- from the component
[code php]
$this->postPager = $this->getPager($query);
$this->postPager->setOption('ajax', true);
[/code]
- from the template
[code php]
$postPager->setOption('ajax', true);
$postPager->renderNavigationTop();
[/code]
- from *apps/front/config/dm/services.yml*
[code]
parameters:
  front_pager_view.options:
    ajax: true
[/code]
Options setted with the services.yml file will apply on all pagers.

### Ajax links
You can decide that the pager no more reloads the page, but only the list widget with Ajax.
It's as simple as setting the 'ajax' option to true:
[code php]
$pager->setOption('ajax', true);
[/code]

Users which browser supports JavaScript will enjoy Ajax interactions.
The ajax pager gracefully degrades, so other users and search engine spiders can still use it normally.

### First, Prev, Next, Last buttons
All these links can be customized.
[code php]
$pager
->setOption('first', __('First page'))  // use a translated text for first button
->setOption('prev', _media('prev.png')) // use an image for prev button
->setOption('next', _tag('span.next'))     // use HTML for next button
->setOption('last', false);             // disable last button
[/code]

### Separator
If set, a separator li is added between all links. Defaults to false.
[code php]
$pager->setOption('separator', '|');
[/code]

### Nb links
Specify the maximum number of page links. Defaults to 9.
[code php]
$pager->setOption('nb_links', 3);
[/code]
Will output a maximum of 3 page links.

### Css classes
You can add CSS classes to the pager with the class option
[code php]
$pager->setOption('class', 'my_pager');
[/code]
Or with a CSS expression when rendering the pager links:
[code php]
echo $postPager->renderNavigationTop('.my_pager_top');
[/code]

### Url parameters
You can add url parameters to the pagination links with the url_params option.
[code php]
$pager->setOption('url_params', array('name' => value'));
[/code]
This will add "&name=value" to all pagination links.

### Current class
Class applied to the li tag of the current page. Defaults to current.
[code php]
$pager->setOption('current_class', 'current_element');
[/code]